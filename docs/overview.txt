File.........: overview.txt
Content......: Overview of how crosstool-NG works.
Copyrigth....: (C) 2007 Yann E. MORIN <yann.morin.1998@anciens.enib.fr>
License......: Creative Commons Attribution Share Alike (CC-by-sa), v2.5

________________
               /
Introduction  /
_____________/

crosstool-NG aims at building toolchains. Toolchains are an essential component
in a software development project. It will compile, assemble and link the code
that is being developed. Some pieces of the toolchain will eventually end up
in the resulting binary/ies: static libraries are but an example.

So, a toolchain is a very sensitive piece of software, as any bug in one of the
components, or a poorly configured component, can lead to execution problems,
ranging from poor performance, to applications ending unexpectedly, to
mis-behaving software (which more than often is hard to detect), to hardware
damage, or even to human risks (which is more than regrettable).

Toolchains are made of different piece of software, each being quite complex
and requiring specially crafted options to build and work seamlessly. This
is usually not that easy, even in the not-so-trivial case of native toolchains.
The work reaches a higher degree of complexity when it comes to cross-
compilation, where it can become quite a nightmare...

Some cross-toolchains exist on the internet, and can be used for general
development, but they have a number of limitations:
  - they can be general purpose, in that they are configured for the majority:
    no optimisation for your specific target,
  - they can be prepared for a specific target and thus are not easy to use,
    nor optimised for, or even supporting your target,
  - they often are using aging components (compiler, C library, etc...) not
    supporting special features of your shiny new processor;
On the other side, these toolchain offer some advantages:
  - they are ready to use and quite easy to install and setup,
  - they are proven if used by a wide community.

But once you want to get all the juice out of your specific hardware, you will
want to build your own toolchain. This is where crosstool-NG comes into play.

There are also a number of tools that build toolchains for specific needs,
which are not really scalable. Examples are:
  - buildroot (buildroot.uclibc.org) whose main purpose is to build root file
    systems, hence the name. But once you have your toolchain with buildroot,
    part of it is installed in the root-to-be, so if you want to build a whole
    new root, you either have to save the existing one as a template and
    restore it later, or restart again from scratch. This is not convenient,
  - ptxdist (www.pengutronix.de/software/ptxdist), whose purpose is very
    similar to buildroot,
  - other projects (openembedded.org for example), which is again used to
    build root file systems.

crosstool-NG is really targeted at building toolchains, and only toolchains.
It is then up to you to use it the way you want.

___________
          /
History  /
________/

crosstool was first 'conceived' by Dan Kegel, who offered it to the community
as a set of scripts, a repository of patches, and some pre-configured, general
purpose setup files to be used to configure crosstool. This is available at
http://www.kegel.com/crosstool, and the subversion repository is hosted on
google at http://code.google.com/p/crosstool/.

I once managed to add support for uClibc-based toolchains, but it did not make
into mainline, mostly because I didn't have time to port the patch forward to
the new versions, due in part to the big effort it was taking.

So I decided to clean up crosstool in the state it was, re-order the things
in place, add appropriate support for what I needed, that is uClibc support
and a menu-driven configuration, named the new implementation crosstool-NG,
(standing for crosstool Next Generation, as many other comunity projects do,
and as a wink at the TV series "Star Trek: The Next Generation" ;-) ) and
made it available to the community, in case it was of interest to any one.

___________________________
                          /
Installing crosstool-NG  /
________________________/

There are two ways you can use crosstool-NG:
 - build and install it, then get rid of the sources like you'd do for most
   programs,
 - or only build it and run from the source directory.

The former should be used if you got crosstool-NG from a packaged tarball, see
"Install method", below, while the latter is most useful for developpers that
checked the code out from SVN, and want to submit patches, see "The Hacker's
way", below.

Install method |
---------------+

If you go for the install, then you just follow the classical, but yet easy
./configure way:
  ./configure --prefix=/some/place
  make
  make install
  export PATH="${PATH}:/some/place/bin"

You can then get rid of crosstool-NG source. Next create a directory to serve
as a working place, cd in there and run:
  ct-ng help

See below for complete usage.

The Hacker's way |
-----------------+

If you go the hacker's way, then the usage is a bit different, although very
simple:
  ./configure --local
  make

Now, *do not* remove crosstool-NG sources. They are needed to run crosstool-NG!
Stay in the directory holding the sources, and run:
  ./ct-ng help

See below for complete usage.

Now, provided you checked-out the code, you can send me your interesting changes
by running:
  svn diff

and mailing me the result! :-P

Contributed code |
-----------------+

Some people contibuted code that couldn't get merged for various reasons. This
code is available as patches in the contrib/ sub-directory. These patches are
to be applied to the source of crosstool-NG, prior to installing.

____________________________
                           /
Configuring crosstool-NG  /
_________________________/

crosstool-NG is configured by a configurator presenting a menu-stuctured set of
options. These options let you specify the way you want your toolchain built,
where you want it installed, what architecture and specific processor it
will support, the version of the components you want to use, etc... The
value for those options are then stored in a configuration file.

The configurator works the same way you configure your Linux kernel. It is
assumed you now how to handle this.

To enter the menu, type:
  ct-ng menuconfig

Almost every config item has a help entry. Read them carefully.

String and number options can refer to environment variables. In such a case,
you must use the shell syntax: ${VAR}. You shall neither single- nor double-
quote the string/number options.

There are three environment variables that are computed by crosstool-NG, and
that you can use:

CT_TARGET:
  It represents the target tuple you are building for. You can use it for
  example in the installation/prefix directory, such as:
    /opt/x-tools/${CT_TARGET}

CT_TOP_DIR:
  The top directory where crosstool-NG is running. You shouldn't need it in
  most cases. There is one case where you may need it: if you have local
  patches and you store them in your running directory, you can refer to them
  by using CT_TOP_DIR, such as:
    ${CT_TOP_DIR}/patches.myproject

CT_VERSION:
  The version of crosstool-NG you are using. Not much use for you, but it's
  there if you need it.

Interesting config options |
---------------------------+

CT_LOCAL_TARBALLS_DIR:
  If you already have some tarballs in a direcotry, enter it here. That will
  speed up the retrieving phase, where crosstool-NG would otherwise download
  those tarballs.

CT_PREFIX_DIR:
  This is where the toolchain will be installed in (and for now, where it
  will run from). Common use is to add the target tuple in the directory
  path, such as (see above):
    /opt/x-tools/${CT_TARGET}

CT_TARGET_VENDOR:
  An identifier for your toolchain, will take place in the vendor part of the
  target tuple. It shall *not* contain spaces or dashes. Usually, keep it
  to a one-word string, or use underscores to separate words if you need.
  Avoid dots, commas, and special characters.

CT_TARGET_ALIAS:
  An alias for the toolchian. It will be used as a prefix to the toolchain
  tools. For example, you will have ${CT_TARGET_ALIAS}-gcc

Also, if you think you don't see enough versions, you can try to enable one of
those:

CT_OBSOLETE:
  Show obsolete versions or tools. Most of the time, you don't want to base
  your toolchain on too old a version (of gcc, for example). But at times, it
  can come handy to use such an old version for regression tests. Those old
  versions are hidden behind CT_OBSOLETE.

CT_EXPERIMENTAL:
  Show experimental versions or tools. Again, you might not want to base your
  toolchain on too recent tools (eg. gcc) for production. But if you need a
  feature present only in a recent version, or a new tool, you can find them
  hidden behind CT_EXPERIMENTAL.

CT_BROKEN:
  Show broken versions or tools. Some usefull tools are currently broken: they
  won't compile, run, or worse, cause defects when running. But if you are
  brave enough, you can try and debug them. They are hidden behind CT_BROKEN,
  which itself is hidden behind CT_EXPERIMENTAL.

Re-building an existing toolchain |
----------------------------------+

If you have an existing toolchain, you can re-use the options used to build it
to create a new toolchain. That needs a very little bit of effort on your side
but is quite easy. The options to build a toolchain are saved in the build log
file that is saved within the toolchain. crosstool-NG can extract those options
to recreate a new configuration:
  ct-ng extractconfig </path/to/your/build.log

will extract those options, prompt you for the new ones, which you can later
edit with menuconfig.

Of course, if your build log was compressed, you'd have to use something like:
  bzcat /path/to/your/build.log.bz2 |ct-ng extractconfig

________________________
                       /
Running crosstool-NG  /
_____________________/

To build the toolchain, simply type:
  ct-ng build

This will use the above configuration to retrieve, extract and patch the
components, build, install and eventually test your newly built toolchain.

You are then free to add the toolchain /bin directory in your PATH to use
it at will.

In any case, you can get some terse help. Just type:
  ct-ng help
or:
  man 1 ct-ng

Stopping and restarting a build |
--------------------------------+

If you want to stop the build after a step you are debugging, you can pass the
variable STOP to make:
  ct-ng STOP=some_step

Conversely, if you want to restart a build at a specific step you are
debugging, you can pass the RESTART variable to make:
  ct-ng RESTART=some_step

Alternatively, you can call make with the name of a step to just do that step:
  ct-ng libc_headers
is equivalent to:
  ct-ng RESTART=libs_headers STOP=libc_headers

The shortcuts +step_name and step_name+ allow to respectively stop or restart
at that step. Thus:
  ct-ng +libc_headers        and:    ct-ng libc_headers+
are equivalent to:
  ct-ng STOP=libc_headers    and:    ct-ng RESTART=libc_headers

To obtain the list of acceptable steps, please call:
  ct-ng liststeps

Note that in order to restart a build, you'll have to say 'Y' to the config
option CT_DEBUG_CT_SAVE_STEPS, and that the previous build effectively went
that far.

Testing all toolchains at once |
-------------------------------+

You can test-build all samples; simply call:
  ct-ng regtest

Overriding the number of // jobs |
---------------------------------+

If you want to override the number of jobs to run in // (the -j option to
make), you can either re-enter the menuconfig, or simply add it on the command
line, as such:
  ct-ng build.4

which tells crosstool-NG to override the number of // jobs to 4.

You can see the actions that support overriding the number of // jobs in
the help menu. Those are the ones with [.#] after them (eg. build[.#] or
regtest[.#], and so on...).

_______________________
                      /
Using the toolchain  /
____________________/

Using the toolchain is as simple as adding the toolchain's bin directory in
your PATH, such as:
  export PATH="${PATH}:/your/toolchain/path/bin"

and then using the target tuple to tell the build systems to use your
toolchain:
  ./configure --target=your-target-tuple
or
  make CC=your-target-tuple-gcc
or
  make CROSS_COMPILE=your-target-tuple-
and so on...

It is strongly advised not to use the toolchain sys-root directory as an
install directory for your programms/packages. If you do so, you will not be
able to use your toolchain for another project. It is even strongly advised
that your toolchain is chmod-ed to read-only once successfully build, so that
you don't go polluting your toolchain with your programms/packages' files.

Thus, when you build a program/package, install it in a separate directory,
eg. /your/root. This directory is the /image/ of what would be in the root file
system of your target, and will contain all that your programms/packages have
installed.

When your root directory is ready, it is still missing some important bits: the
toolchain's libraries. To populate your root directory with those libs, just
run:
  your-target-tuple-populate -s /your/root -d /your/root-populated

This will copy /your/root into /your/root-populated, and put the needed and only
the needed libraries there. Thus you don't polute /your/root with any cruft that
would no longer be needed should you have to remove stuff. /your/root always
contains only those things you install in it.

You can then use /your/root-populated to build up your file system image, a
tarball, or to NFS-mount it from your target, or whatever you need.

populate accepts the following options:

 -s [src_dir]
    Use 'src_dir' as the 'source', un-populated root directory

 -d [dst_dir]
    Put the 'destination', populated root directory in 'dst_dir'

 -f
    Remove 'dst_dir' if it previously existed

 -v
    Be verbose, and tell what's going on (you can see exactly where libs are
    coming from).

 -h
    Print the help

___________________
                  /
Toolchain types  /
________________/

There are four kinds of toolchains you could encounter.

First off, you must understand the following: when it comes to compilers there
are up to four machines involved:
  1) the machine configuring the toolchain components: the config machine
  2) the machine building the toolchain components:    the build machine
  3) the machine running the toolchain:                the host machine
  4) the machine the toolchain is generating code for: the target machine

We can most of the time assume that the config machine and the build machine
are the same. Most of the time, this will be true. The only time it isn't
is if you're using distributed compilation (such as distcc). Let's forget
this for the sake of simplicity.

So we're left with three machines:
 - build
 - host
 - target

Any toolchain will involve those three machines. You can be as pretty sure of
this as "2 and 2 are 4". Here is how they come into play:

1) build == host == target
    This is a plain native toolchain, targetting the exact same machine as the
    one it is built on, and running again on this exact same machine. You have
    to build such a toolchain when you want to use an updated component, such
    as a newer gcc for example.
    crosstool-NG calls it "native".

2) build == host != target
    This is a classic cross-toolchain, which is expected to be run on the same
    machine it is compiled on, and generate code to run on a second machine,
    the target.
    crosstool-NG calls it "cross".

3) build != host == target
    Such a toolchain is also a native toolchain, as it targets the same machine
    as it runs on. But it is build on another machine. You want such a
    toolchain when porting to a new architecture, or if the build machine is
    much faster than the host machine.
    crosstool-NG calls it "cross-native".

4) build != host != target
    This one is called a canadian-toolchain (*), and is tricky. The three
    machines in play are different. You might want such a toolchain if you
    have a fast build machine, but the users will use it on another machine,
    and will produce code to run on a third machine.
    crosstool-NG calls it "canadian".

crosstool-NG can build all these kinds of toolchains (or is aiming at it,
anyway!)

(*) The term Canadian Cross came about because at the time that these issues
    were all being hashed out, Canada had three national political parties.
    http://en.wikipedia.org/wiki/Cross_compiler

_____________
            /
Internals  /
__________/

Internally, crosstool-NG is script-based. To ease usage, the frontend is
Makefile-based.

Makefile front-end |
-------------------+

The entry point to crosstool-NG is the Makefile script "ct-ng". Calling this
script with an action will act exactly as if the Makefile was in the current
working directory and make was called with the action as rule. Thus:
  ct-ng menuconfig

is equivalent to having the Makefile in CWD, and calling:
  make menuconfig

Having ct-ng as it is avoids copying the Makefile everywhere, and acts as a
traditional command.

ct-ng loads sub- Makefiles from the library directory $(CT_LIB_DIR), as set up
at configuration time with ./configure.

ct-ng also searches for config files, sub-tools, samples, scripts and patches in
that library directory.

Because of a stupid make behavior/bug I was unable to track down, implicit make
rules are disabled: installing with --local would triger those rules, and mconf
was unbuildable.

Kconfig parser |
---------------+

The kconfig language is a hacked version, vampirised from the toybox project
by Rob LANDLEY (http://www.landley.net/code/toybox/), itself coming from the
Linux kernel (http://www.kernel.org/), and (heavily) adapted to my needs.

The kconfig parsers (conf and mconf) are not installed pre-built, but as
source files. Thus you can have the directory where crosstool-NG is installed,
exported (via NFS or whatever) and have clients with different architectures
use the same crosstool-NG installation, and most notably, the same set of
patches.

Architecture-specific |
----------------------+

An architecture is defined by:

 - a human-readable name, in lower case letters, with numbers as appropriate.
   The underscore is allowed. Eg.: arm, x86_64
 - a boolean kconfig option named after the architecture (in capital letters
   if possible) prefixed with "ARCH_". Eg.: ARCH_ARM, ARCH_x86_64
 - a directory in "arch/" named after the architecture, with the same letters
   as above. Eg.: arch/arm, arch/x86_64
   This directory contains:
   - a configuration file in kconfig syntax, named "config.in", which may be
     empty. Eg.: arch/arm/config.in
   - a function script in bash-3.0 syntax, named "functions", which shall
     follow the API defined below. Eg.: arch/arm/functions

The "functions" file API:
 > the function "CT_DoArchValues"
   + parameters: none
   + environment:
      - all variables from the ".config" file,
      - the two variables "target_endian_eb" and "target_endian_el" which are
        the endianness suffixes
   + return value: 0 upon success, !0 upon failure
   + provides:
     - mandatory
     - the environment variable CT_TARGET_ARCH
     - contains:
       the architecture part of the target tuple.
       Eg.: "armeb" for big endian ARM
            "i386" for an i386
   + provides:
     - optional
     - the environment variable CT_TARGET_SYS
     - contains:
       the sytem part of the target tuple.
       Eg.: "gnu" for glibc on most architectures
            "gnueabi" for glibc on an ARM EABI
     - defaults to:
       - for glibc-based toolchain: "gnu"
       - for uClibc-based toolchain: "uclibc"
   + provides:
     - optional
     - the environment variable CT_KERNEL_ARCH
     - contains:
       the architecture name as understandable by the Linux kernel build
       system.
       Eg.: "arm" for an ARM
            "powerpc" for a PowerPC
            "i386" for an x86
     - defaults to:
       ${CT_ARCH}
   + provides:
     - optional
     - the environment variables to configure the cross-gcc
       - CT_ARCH_WITH_ARCH
       - CT_ARCH_WITH_ABI
       - CT_ARCH_WITH_CPU
       - CT_ARCH_WITH_TUNE
       - CT_ARCH_WITH_FPU
       - CT_ARCH_WITH_FLOAT
     - contain (defaults):
       - CT_ARCH_WITH_ARCH    : the gcc ./configure switch to select architecture level         ( "--with-arch=${CT_ARCH_ARCH}"       )
       - CT_ARCH_WITH_ABI     : the gcc ./configure switch to select ABI level                  ( "--with-abi=${CT_ARCH_ABI}"         )
       - CT_ARCH_WITH_CPU     : the gcc ./configure switch to select CPU instruction set        ( "--with-cpu=${CT_ARCH_CPU}"         )
       - CT_ARCH_WITH_TUNE    : the gcc ./configure switch to select scheduling                 ( "--with-tune=${CT_ARCH_TUNE}"       )
       - CT_ARCH_WITH_FPU     : the gcc ./configure switch to select FPU type                   ( "--with-fpu=${CT_ARCH_FPU}"         )
       - CT_ARCH_WITH_FLOAT   : the gcc ./configure switch to select floating point arithmetics ( "--with-float=soft" or /empty/      )
   + provides:
     - optional
     - the environment variables to pass to the cross-gcc to build target binaries
       - CT_ARCH_ARCH_CFLAG
       - CT_ARCH_ABI_CFLAG
       - CT_ARCH_CPU_CFLAG
       - CT_ARCH_TUNE_CFLAG
       - CT_ARCH_FPU_CFLAG
       - CT_ARCH_FLOAT_CFLAG
       - CT_ARCH_ENDIAN_CFLAG
     - contain (defaults):
       - CT_ARCH_ARCH_CFLAG   : the gcc switch to select architecture level                     ( "-march=${CT_ARCH_ARCH}"            )
       - CT_ARCH_ABI_CFLAG    : the gcc switch to select ABI level                              ( "-mabi=${CT_ARCH_ABI}"              )
       - CT_ARCH_CPU_CFLAG    : the gcc switch to select CPU instruction set                    ( "-mcpu=${CT_ARCH_CPU}"              )
       - CT_ARCH_TUNE_CFLAG   : the gcc switch to select scheduling                             ( "-mtune=${CT_ARCH_TUNE}"            )
       - CT_ARCH_FPU_CFLAG    : the gcc switch to select FPU type                               ( "-mfpu=${CT_ARCH_FPU}"              )
       - CT_ARCH_FLOAT_CFLAG  : the gcc switch to choose floating point arithmetics             ( "-msoft-float" or /empty/           )
       - CT_ARCH_ENDIAN_CFLAG : the gcc switch to choose big or little endian                   ( "-mbig-endian" or "-mlittle-endian" )
     - default to:
       see above.
     
Adding a new version of a conponent |
------------------------------------+

When a new component, such as the Linux kernel, gcc or any other is released,
adding the new version to crosstool-NG is quite easy. There is a script that
will do all that for you:
  tools/addToolVersion.sh

Run it with no option to get some help.

Build scripts |
--------------+

To Be Written later...
