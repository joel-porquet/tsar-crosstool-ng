# This file contains some usefull common functions
# Copyright 2007 Yann E. MORIN
# Licensed under the GPL v2. See COPYING in the root of this package

# Prepare the fault handler
CT_OnError() {
    ret=$?
    CT_DoLog ERROR "Build failed in step \"${CT_STEP_MESSAGE[${CT_STEP_COUNT}]}\""
    for((step=(CT_STEP_COUNT-1); step>1; step--)); do
        CT_DoLog ERROR "      called in step \"${CT_STEP_MESSAGE[${step}]}\""
    done
    CT_DoLog ERROR "Error happened in \"${BASH_SOURCE[1]}\" in function \"${FUNCNAME[1]}\" (line unknown, sorry)"
    for((depth=2; ${BASH_LINENO[$((${depth}-1))]}>0; depth++)); do
        CT_DoLog ERROR "      called from \"${BASH_SOURCE[${depth}]}\" at line # ${BASH_LINENO[${depth}-1]} in function \"${FUNCNAME[${depth}]}\""
    done
    [ "${CT_LOG_TO_FILE}" = "y" ] && CT_DoLog ERROR "Look at \"${CT_LOG_FILE}\" for more info on this error."
    CT_STEP_COUNT=1
    CT_DoEnd ERROR
    exit $ret
}

# Install the fault handler
trap CT_OnError ERR

# Inherit the fault handler in subshells and functions
set -E

# Make pipes fail on the _first_ failed command
# Not supported on bash < 3.x, but we need it, so drop the obsoleting bash-2.x
set -o pipefail

# Don't hash commands' locations, and search every time it is requested.
# This is slow, but needed because of the static/shared core gcc which shall
# always match to shared if it exists, and only fallback to static if the
# shared is not found
set +o hashall

# The different log levels:
CT_LOG_LEVEL_ERROR=0
CT_LOG_LEVEL_WARN=1
CT_LOG_LEVEL_INFO=2
CT_LOG_LEVEL_EXTRA=3
CT_LOG_LEVEL_DEBUG=4
CT_LOG_LEVEL_ALL=5

# A function to log what is happening
# Different log level are available:
#   - ERROR:   A serious, fatal error occurred
#   - WARN:    A non fatal, non serious error occurred, take your responsbility with the generated build
#   - INFO:    Informational messages
#   - EXTRA:   Extra informational messages
#   - DEBUG:   Debug messages
#   - ALL:     Component's build messages
# Usage: CT_DoLog <level> [message]
# If message is empty, then stdin will be logged.
CT_DoLog() {
    local max_level LEVEL level cur_l cur_L
    local l
    eval max_level="\${CT_LOG_LEVEL_${CT_LOG_LEVEL_MAX}}"
    # Set the maximum log level to DEBUG if we have none
    [ -z "${max_level}" ] && max_level=${CT_LOG_LEVEL_DEBUG}

    LEVEL="$1"; shift
    eval level="\${CT_LOG_LEVEL_${LEVEL}}"

    if [ $# -eq 0 ]; then
        cat -
    else
        echo "${1}"
    fi |( IFS="\n" # We want the full lines, even leading spaces
          CT_PROG_BAR_CPT=0
          indent=$((2*CT_STEP_COUNT))
          while read line; do
              case "${CT_LOG_SEE_TOOLS_WARN},${line}" in
                y,*"warning:"*)         cur_L=WARN; cur_l=${CT_LOG_LEVEL_WARN};;
                y,*"WARNING:"*)         cur_L=WARN; cur_l=${CT_LOG_LEVEL_WARN};;
                *"error:"*)             cur_L=ERROR; cur_l=${CT_LOG_LEVEL_ERROR};;
                *"make["?*"]:"*"Stop.") cur_L=ERROR; cur_l=${CT_LOG_LEVEL_ERROR};;
                *)                      cur_L="${LEVEL}"; cur_l="${level}";;
              esac
              l="`printf \"[%-5s]%*s%s%s\" \"${cur_L}\" \"${indent}\" \" \" \"${line}\"`"
              # There will always be a log file, be it /dev/null
              echo -e "${l}"
              if [ ${cur_l} -le ${max_level} ]; then
                  echo -e "\r${l}" >&6
              fi
              if [ "${CT_LOG_PROGRESS_BAR}" = "y" ]; then
                  [ ${CT_PROG_BAR_CPT} -eq 0  ] && bar="/"
                  [ ${CT_PROG_BAR_CPT} -eq 10 ] && bar="-"
                  [ ${CT_PROG_BAR_CPT} -eq 20 ] && bar="\\"
                  [ ${CT_PROG_BAR_CPT} -eq 30 ] && bar="|"
                  printf "\r[%02d:%02d] %s " $((SECONDS/60)) $((SECONDS%60)) "${bar}" >&6
                  CT_PROG_BAR_CPT=$(((CT_PROG_BAR_CPT+1)%40))
              fi
          done
        )

    return 0
}

# Tail message to be logged whatever happens
# Usage: CT_DoEnd <level>
CT_DoEnd()
{
    CT_STOP_DATE=`CT_DoDate +%s%N`
    CT_STOP_DATE_HUMAN=`CT_DoDate +%Y%m%d.%H%M%S`
    CT_DoLog INFO "Build completed at ${CT_STOP_DATE_HUMAN}"
    elapsed=$((CT_STOP_DATE-CT_STAR_DATE))
    elapsed_min=$((elapsed/(60*1000*1000*1000)))
    elapsed_sec=`printf "%02d" $(((elapsed%(60*1000*1000*1000))/(1000*1000*1000)))`
    elapsed_csec=`printf "%02d" $(((elapsed%(1000*1000*1000))/(10*1000*1000)))`
    CT_DoLog ${1:-INFO} "(elapsed: ${elapsed_min}:${elapsed_sec}.${elapsed_csec})"
}

# Abort the execution with an error message
# Usage: CT_Abort <message>
CT_Abort() {
    CT_DoLog ERROR "$1"
    exit 1
}

# Test a condition, and print a message if satisfied
# Usage: CT_Test <message> <tests>
CT_Test() {
    local ret
    local m="$1"
    shift
    test "$@" && CT_DoLog WARN "$m"
    return 0
}

# Test a condition, and abort with an error message if satisfied
# Usage: CT_TestAndAbort <message> <tests>
CT_TestAndAbort() {
    local m="$1"
    shift
    test "$@" && CT_Abort "$m"
    return 0
}

# Test a condition, and abort with an error message if not satisfied
# Usage: CT_TestAndAbort <message> <tests>
CT_TestOrAbort() {
    local m="$1"
    shift
    test "$@" || CT_Abort "$m"
    return 0
}

# Test the presence of a tool, or abort if not found
# Usage: CT_HasOrAbort <tool>
CT_HasOrAbort() {
    CT_TestAndAbort "\"${1}\" not found and needed for successfull toolchain build." -z "`which \"${1}\"`"
    return 0
}

# Get current date with nanosecond precision
# On those system not supporting nanosecond precision, faked with rounding down
# to the highest entire second
# Usage: CT_DoDate <fmt>
CT_DoDate() {
    date "$1" |sed -r -e 's/%N$/000000000/;'
}

CT_STEP_COUNT=1
CT_STEP_MESSAGE[${CT_STEP_COUNT}]="<none>"
# Memorise a step being done so that any error is caught
# Usage: CT_DoStep <loglevel> <message>
CT_DoStep() {
    local start=`CT_DoDate +%s%N`
    CT_DoLog "$1" "================================================================="
    CT_DoLog "$1" "$2"
    CT_STEP_COUNT=$((CT_STEP_COUNT+1))
    CT_STEP_LEVEL[${CT_STEP_COUNT}]="$1"; shift
    CT_STEP_START[${CT_STEP_COUNT}]="${start}"
    CT_STEP_MESSAGE[${CT_STEP_COUNT}]="$1"
    return 0
}

# End the step just being done
# Usage: CT_EndStep
CT_EndStep() {
    local stop=`CT_DoDate +%s%N`
    local duration=`printf "%032d" $((stop-${CT_STEP_START[${CT_STEP_COUNT}]})) |sed -r -e 's/([[:digit:]]{2})[[:digit:]]{7}$/\.\1/; s/^0+//; s/^\./0\./;'`
    local level="${CT_STEP_LEVEL[${CT_STEP_COUNT}]}"
    local message="${CT_STEP_MESSAGE[${CT_STEP_COUNT}]}"
    CT_STEP_COUNT=$((CT_STEP_COUNT-1))
    CT_DoLog "${level}" "${message}: done in ${duration}s"
    return 0
}

# Pushes into a directory, and pops back
CT_Pushd() {
    pushd "$1" >/dev/null 2>&1
}
CT_Popd() {
    popd >/dev/null 2>&1
}

# Makes a path absolute
# Usage: CT_MakeAbsolutePath path
CT_MakeAbsolutePath() {
    # Try to cd in that directory
    if [ -d "$1" ]; then
        CT_Pushd "$1"
        pwd
        CT_Popd
    else
        # No such directory, fail back to guessing
        case "$1" in
            /*)  echo "$1";;
            *)   echo "`pwd`/$1";;
        esac
    fi
    
    return 0
}

# Creates a temporary directory
# $1: variable to assign to
# Usage: CT_MktempDir foo
CT_MktempDir() {
    # Some mktemp do not allow more than 6 Xs
    eval "$1"="`mktemp -q -d \"${CT_BUILD_DIR}/.XXXXXX\"`"
    CT_TestOrAbort "Could not make temporary directory" -n "${!1}" -a -d "${!1}"
}

# Echoes the specified string on stdout until the pipe breaks.
# Doesn't fail
# $1: string to echo
# Usage: CT_DoYes "" |make oldconfig
CT_DoYes() {
    yes "$1" || true
}

# Get the file name extension of a component
# Usage: CT_GetFileExtension <component_name-component_version>
# If found, echoes the extension to stdout
# If not found, echoes nothing on stdout.
CT_GetFileExtension() {
    local ext
    local file="$1"
    local got_it=1

    CT_Pushd "${CT_TARBALLS_DIR}"
    for ext in .tar.gz .tar.bz2 .tgz .tar; do
        if [ -f "${file}${ext}" ]; then
            echo "${ext}"
            got_it=0
            break
        fi
    done
    CT_Popd

    return 0
}

# Download an URL using wget
# Usage: CT_DoGetFileWget <URL>
CT_DoGetFileWget() {
    # Need to return true because it is legitimate to not find the tarball at
    # some of the provided URLs (think about snapshots, different layouts for
    # different gcc versions, etc...)
    # Some (very old!) FTP server might not support the passive mode, thus
    # retry without
    # With automated download as we are doing, it can be very dangerous to use
    # -c to continue the downloads. It's far better to simply overwrite the
    # destination file
    wget -nc --progress=dot:binary --tries=3 --passive-ftp "$1" || wget -nc --progress=dot:binary --tries=3 "$1" || true
}

# Download an URL using curl
# Usage: CT_DoGetFileCurl <URL>
CT_DoGetFileCurl() {
	# Note: comments about wget method are also valid here
	# Plus: no good progreess indicator is available with curl,
	#       so output is consigned to oblivion
	curl --ftp-pasv -O --retry 3 "$1" >/dev/null || curl -O --retry 3 "$1" >/dev/null || true
}

# Wrapper function to call one of curl or wget
# Usage: CT_DoGetFile <URL>
CT_DoGetFile() {
    local _wget=`which wget`
    local _curl=`which curl`
    case "${_wget},${_curl}" in
        ,)  CT_DoError "Could find neither wget nor curl";;
        ,*) CT_DoGetFileCurl "$1" 2>&1 |CT_DoLog DEBUG;;
        *)  CT_DoGetFileWget "$1" 2>&1 |CT_DoLog DEBUG;;
    esac
}

# Download the file from one of the URLs passed as argument
# Usage: CT_GetFile <filename> <url> [<url> ...]
CT_GetFile() {
    local got_it
    local ext
    local url
    local file="$1"
    shift

    # Do we already have it?
    ext=`CT_GetFileExtension "${file}"`
    if [ -n "${ext}" ]; then
        CT_DoLog DEBUG "Already have \"${file}\""
        return 0
    fi

    CT_Pushd "${CT_TARBALLS_DIR}"
    # File not yet downloaded, try to get it
    got_it=0
    # We'd rather have a bzip2'ed tarball, then gzipped, and finally plain tar.
    # Try local copy first, if it exists
    for ext in .tar.bz2 .tar.gz .tgz .tar; do
        if [ -r "${CT_LOCAL_TARBALLS_DIR}/${file}${ext}" -a \
             "${CT_FORCE_DOWNLOAD}" != "y" ]; then
            CT_DoLog EXTRA "Copying \"${file}\" from local copy"
            cp -v "${CT_LOCAL_TARBALLS_DIR}/${file}${ext}" "${file}${ext}" |CT_DoLog ALL
            return 0
        fi
    done
    # Try to download it
    CT_DoLog EXTRA "Retrieving \"${file}\""
    for ext in .tar.bz2 .tar.gz .tgz .tar; do
        # Try all urls in turn
        for url in "$@"; do
            case "${url}" in
                *)  CT_DoLog DEBUG "Trying \"${url}/${file}${ext}\""
                    CT_DoGetFile "${url}/${file}${ext}"
                    ;;
            esac
            [ -f "${file}${ext}" ] && return 0 || true
        done
    done
    CT_Popd

    CT_Abort "Could not download \"${file}\", and not present in \"${CT_LOCAL_TARBALLS_DIR}\""
}

# Extract a tarball and patch the resulting sources if necessary.
# Some tarballs need to be extracted in specific places. Eg.: glibc addons
# must be extracted in the glibc directory; uCLibc locales must be extracted
# in the extra/locale sub-directory of uClibc.
CT_ExtractAndPatch() {
    local file="$1"
    local base_file=`echo "${file}" |cut -d - -f 1`
    local ver_file=`echo "${file}" |cut -d - -f 2-`
    local official_patch_dir
    local custom_patch_dir
    local libc_addon
    local ext=`CT_GetFileExtension "${file}"`
    CT_TestAndAbort "\"${file}\" not found in \"${CT_TARBALLS_DIR}\"" -z "${ext}"
    local full_file="${CT_TARBALLS_DIR}/${file}${ext}"

    CT_Pushd "${CT_SRC_DIR}"

    # Add-ons need a little love, really.
    case "${file}" in
        glibc-[a-z]*-*)
            CT_TestAndAbort "Trying to extract the C-library addon/locales \"${file}\" when C-library not yet extracted" ! -d "${CT_LIBC_FILE}"
            cd "${CT_LIBC_FILE}"
            libc_addon=y
            [ -f ".${file}.extracted" ] && return 0
            touch ".${file}.extracted"
            ;;
        uClibc-locale-*)
            CT_TestAndAbort "Trying to extract the C-library addon/locales \"${file}\" when C-library not yet extracted" ! -d "${CT_LIBC_FILE}"
            cd "${CT_LIBC_FILE}/extra/locale"
            libc_addon=y
            [ -f ".${file}.extracted" ] && return 0
            touch ".${file}.extracted"
            ;;
    esac

    # If the directory exists, then consider extraction and patching done
    if [ -d "${file}" ]; then
        CT_DoLog DEBUG "Already extracted \"${file}\""
        return 0
    fi

    CT_DoLog EXTRA "Extracting \"${file}\""
    case "${ext}" in
        .tar.bz2)     tar xvjf "${full_file}" |CT_DoLog ALL;;
        .tar.gz|.tgz) tar xvzf "${full_file}" |CT_DoLog ALL;;
        .tar)         tar xvf  "${full_file}" |CT_DoLog ALL;;
        *)            CT_Abort "Don't know how to handle \"${file}\": unknown extension" ;;
    esac

    # Snapshots might not have the version number in the extracted directory
    # name. This is also the case for some (old) packages, such as libfloat.
    # Overcome this issue by symlink'ing the directory.
    if [ ! -d "${file}" -a "${libc_addon}" != "y" ]; then
        case "${ext}" in
            .tar.bz2)     base=`tar tjf "${full_file}" |head -n 1 |cut -d / -f 1 || true`;;
            .tar.gz|.tgz) base=`tar tzf "${full_file}" |head -n 1 |cut -d / -f 1 || true`;;
            .tar)         base=`tar tf  "${full_file}" |head -n 1 |cut -d / -f 1 || true`;;
        esac
        CT_TestOrAbort "There was a problem when extracting \"${file}\"" -d "${base}" -o "${base}" != "${file}"
        ln -s "${base}" "${file}"
    fi

    # Kludge: outside this function, we wouldn't know if we had just extracted
    # a libc addon, or a plain package. Apply patches now.
    CT_DoLog EXTRA "Patching \"${file}\""

    if [ "${libc_addon}" = "y" ]; then
        # Some addons tarball directly contian the correct addon directory,
        # while others have the addon directory named ofter the tarball.
        # Fix that bu always using the short name (eg: linuxthreads, ports, etc...)
        addon_short_name=`echo "${file}" |sed -r -e 's/^[^-]+-//; s/-[^-]+$//;'`
        [ -d "${addon_short_name}" ] || ln -s "${file}" "${addon_short_name}"
        # If libc addon, we're already in the correct place
    else
        cd "${file}"
    fi

    [ "${CUSTOM_PATCH_ONLY}" = "y" ] || official_patch_dir="${CT_TOP_DIR}/patches/${base_file}/${ver_file}"
    [ "${CT_CUSTOM_PATCH}" = "y" ] && custom_patch_dir="${CT_CUSTOM_PATCH_DIR}/${base_file}/${ver_file}"
    for patch_dir in "${official_patch_dir}" "${custom_patch_dir}"; do
        if [ -n "${patch_dir}" -a -d "${patch_dir}" ]; then
            for p in "${patch_dir}"/*.patch; do
                if [ -f "${p}" ]; then
                    CT_DoLog DEBUG "Applying patch \"${p}\""
                    patch -g0 -F1 -p1 -f <"${p}" |CT_DoLog ALL
                    CT_TestAndAbort "Failed while applying patch file \"${p}\"" ${PIPESTATUS[0]} -ne 0
                fi
            done
        fi
    done

    CT_Popd
}

# Compute the target triplet from what is provided by the user
# Usage: CT_DoBuildTargetTriplet
# In fact this function takes the environment variables to build the target
# triplet. It is needed both by the normal build sequence, as well as the
# sample saving sequence.
CT_DoBuildTargetTriplet() {
    case "${CT_ARCH_BE},${CT_ARCH_LE}" in
        y,) target_endian_eb=eb; target_endian_el=;;
        ,y) target_endian_eb=; target_endian_el=el;;
    esac
    case "${CT_ARCH}" in
        arm)  CT_TARGET="${CT_ARCH}${target_endian_eb}";;
        mips) CT_TARGET="${CT_ARCH}${target_endian_el}";;
        x86*) # Much love for this one :-(
              arch="${CT_ARCH_ARCH}"
              [ -z "${arch}" ] && arch="${CT_ARCH_TUNE}"
              case "${CT_ARCH}" in
                  x86_64)  CT_TARGET=x86_64;;
              	  *)  case "${arch}" in
                          "")                                       CT_TARGET=i386;;
                          i386|i486|i586|i686)                      CT_TARGET="${arch}";;
                          winchip*)                                 CT_TARGET=i486;;
                          pentium|pentium-mmx|c3*)                  CT_TARGET=i586;;
                          nocona|athlon*64|k8|athlon-fx|opteron)    CT_TARGET=x86_64;;
                          pentiumpro|pentium*|athlon*)              CT_TARGET=i686;;
                          *)                                        CT_TARGET=i586;;
                      esac;;
              esac;;
    esac
    case "${CT_TARGET_VENDOR}" in
        "") CT_TARGET="${CT_TARGET}-unknown";;
        *)  CT_TARGET="${CT_TARGET}-${CT_TARGET_VENDOR}";;
    esac
    case "${CT_KERNEL}" in
        linux*)  CT_TARGET="${CT_TARGET}-linux";;
    esac
    case "${CT_LIBC}" in
        glibc)  CT_TARGET="${CT_TARGET}-gnu";;
        uClibc) CT_TARGET="${CT_TARGET}-uclibc";;
    esac
    CT_TARGET="`${CT_TOP_DIR}/tools/config.sub ${CT_TARGET}`"
}

# This function does pause the build until the user strikes "Return"
# Usage: CT_DoPause [optional_message]
CT_DoPause() {
    local foo
    local message="${1:-Pausing for your pleasure}"
    CT_DoLog INFO "${message}"
    read -p "Press \"Enter\" to continue, or Ctrl-C to stop..." foo >&6
    return 0
}

# This function saves the state of the toolchain to be able to restart
# at any one point
# Usage: CT_DoSaveState <next_step_name>
CT_DoSaveState() {
	[ "${CT_DEBUG_CT_SAVE_STEPS}" = "y" ] || return 0
    local state_name="$1"
    local state_dir="${CT_STATE_DIR}/${state_name}"

    CT_DoLog DEBUG "Saving state to restart at step \"${state_name}\"..."
    rm -rf "${state_dir}"
    mkdir -p "${state_dir}"

    case "${CT_DEBUG_CT_SAVE_STEPS_GZIP}" in
        y)  tar_opt=czf; tar_ext=".tar.gz";;
        *)  tar_opt=cf;  tar_ext=".tar";;
    esac

    CT_DoLog DEBUG "  Saving environment and aliases"
    # We must omit shell functions
    # 'isgrep' is here because I don't seem to
    # be able to remove the functions names.
    set |awk '
         BEGIN { _p = 1; }
         $0~/^[^ ] ()/ { _p = 0; }
         _p == 1
         $0 == "}" { _p = 1; }
         ' |egrep -v '^[^ ]+ \(\)' >"${state_dir}/env.sh"

    CT_DoLog DEBUG "  Saving CT_CC_CORE_STATIC_PREFIX_DIR=\"${CT_CC_CORE_STATIC_PREFIX_DIR}\""
    CT_Pushd "${CT_CC_CORE_STATIC_PREFIX_DIR}"
    tar ${tar_opt} "${state_dir}/cc_core_static_prefix_dir${tar_ext}" .
    CT_Popd

    CT_DoLog DEBUG "  Saving CT_CC_CORE_SHARED_PREFIX_DIR=\"${CT_CC_CORE_SHARED_PREFIX_DIR}\""
    CT_Pushd "${CT_CC_CORE_SHARED_PREFIX_DIR}"
    tar ${tar_opt} "${state_dir}/cc_core_shared_prefix_dir${tar_ext}" .
    CT_Popd

    CT_DoLog DEBUG "  Saving CT_PREFIX_DIR=\"${CT_PREFIX_DIR}\""
    CT_Pushd "${CT_PREFIX_DIR}"
    tar ${tar_opt} "${state_dir}/prefix_dir${tar_ext}" --exclude '*.log' .
    CT_Popd

    if [ "${CT_LOG_TO_FILE}" = "y" ]; then
        CT_DoLog DEBUG "  Saving log file"
        exec >/dev/null
        case "${CT_DEBUG_CT_SAVE_STEPS_GZIP}" in
            y)  gzip -3 -c "${CT_LOG_FILE}"  >"${state_dir}/log.gz";;
            *)  cat "${CT_LOG_FILE}" >"${state_dir}/log";;
        esac
        exec >>"${CT_LOG_FILE}"
    fi
}

# This function restores a previously saved state
# Usage: CT_DoLoadState <state_name>
CT_DoLoadState(){
    local state_name="$1"
    local state_dir="${CT_STATE_DIR}/${state_name}"
    local old_RESTART="${CT_RESTART}"
    local old_STOP="${CT_STOP}"

    CT_TestOrAbort "The previous build did not reach the point where it could be restarted at \"${CT_RESTART}\"" -d "${state_dir}"

    # We need to do something special with the log file!
    if [ "${CT_LOG_TO_FILE}" = "y" ]; then
        exec >"${state_dir}/tail.log"
    fi
    CT_DoLog INFO "Restoring state at step \"${state_name}\", as requested."

    case "${CT_DEBUG_CT_SAVE_STEPS_GZIP}" in
        y)  tar_opt=xzf; tar_ext=".tar.gz";;
        *)  tar_opt=cf;  tar_ext=".tar";;
    esac

    CT_DoLog DEBUG "  Removing previous build directories"
    chmod -R u+rwX "${CT_PREFIX_DIR}" "${CT_CC_CORE_SHARED_PREFIX_DIR}" "${CT_CC_CORE_STATIC_PREFIX_DIR}"
    rm -rf         "${CT_PREFIX_DIR}" "${CT_CC_CORE_SHARED_PREFIX_DIR}" "${CT_CC_CORE_STATIC_PREFIX_DIR}"
    mkdir -p       "${CT_PREFIX_DIR}" "${CT_CC_CORE_SHARED_PREFIX_DIR}" "${CT_CC_CORE_STATIC_PREFIX_DIR}"

    CT_DoLog DEBUG "  Restoring CT_PREFIX_DIR=\"${CT_PREFIX_DIR}\""
    CT_Pushd "${CT_PREFIX_DIR}"
    tar ${tar_opt} "${state_dir}/prefix_dir${tar_ext}"
    CT_Popd

    CT_DoLog DEBUG "  Restoring CT_CC_CORE_SHARED_PREFIX_DIR=\"${CT_CC_CORE_SHARED_PREFIX_DIR}\""
    CT_Pushd "${CT_CC_CORE_SHARED_PREFIX_DIR}"
    tar ${tar_opt} "${state_dir}/cc_core_shared_prefix_dir${tar_ext}"
    CT_Popd

    CT_DoLog DEBUG "  Restoring CT_CC_CORE_STATIC_PREFIX_DIR=\"${CT_CC_CORE_STATIC_PREFIX_DIR}\""
    CT_Pushd "${CT_CC_CORE_STATIC_PREFIX_DIR}"
    tar ${tar_opt} "${state_dir}/cc_core_static_prefix_dir${tar_ext}"
    CT_Popd

    # Restore the environment, discarding any error message
    # (for example, read-only bash internals)
    CT_DoLog DEBUG "  Restoring environment"
    . "${state_dir}/env.sh" >/dev/null 2>&1 || true

    # Restore the new RESTART and STOP steps
    CT_RESTART="${old_RESTART}"
    CT_STOP="${old_STOP}"
    unset old_stop old_restart

    if [ "${CT_LOG_TO_FILE}" = "y" ]; then
        CT_DoLog DEBUG "  Restoring log file"
        exec >/dev/null
        case "${CT_DEBUG_CT_SAVE_STEPS_GZIP}" in
            y)  zcat "${state_dir}/log.gz" >"${CT_LOG_FILE}";;
            *)  cat "${state_dir}/log" >"${CT_LOG_FILE}";;
        esac
        cat "${state_dir}/tail.log" >>"${CT_LOG_FILE}"
        exec >>"${CT_LOG_FILE}"
        rm -f "${state_dir}/tail.log"
    fi
}
